#include "gameupqt.h"
#include "gameupqt_p.h"
#include <QDebug>

/*!
   \class GameUpQt
   \inmodule GameUpQt

   \brief The GameUpQt is QML item class

   The GameUpQt class inherits QQuickItem. The class give access to
   GameUp API, which is used for maintain gamer's achievments and
   provide Leaderboard ranking for gamers
   Each game should be registered at \l {https://dashboard.gameup.io/} {GameUp dashboard} and the API key
   should be generated. The API key have to be loaded to \l {GameUpQt::} {apiKey}

   GameUp API can work in two modes: sync and async
   \l {GameUpQt::} {asyncMode} responsible for mode
   Recommended way is to design application using async mode

*/

/*!
  \property GameUpQt::apiKey
  \inmodule GameUpQt
  \brief set GameUp API key generated at \l {https://dashboard.gameup.io/} {GameUp dashboard}

  Most of the GameUp API's (except \l {ping} ) requires API key
*/

/*!
    \property GameUpQt::asyncMode
    \inmodule GameUpQt
    \brief set GameUp QML Item mode

    if \l {asyncMode} set as \c true then methods will exit immedialely and all responses will be
    provided via signals
*/

/*!
    \property GameUpQt::webView
    \inmodule GameUpQt
    \brief set WebView item for login procedure

    WebView is required for login procedure. If the property is set to null, only \b anonymouse login will work
*/

/*!
    \property GameUpQt::gamer
    \inmodule GameUpQt
    \brief set WebView item for login procedure

    WebView is required for login procedure. If the property is set to null, only \b anonymouse login will work
*/

/*!
    \property GameUpQt::leaderboard
    \inmodule GameUpQt
    \brief set WebView item for login procedure

    WebView is required for login procedure. If the property is set to null, only \b anonymouse login will work
*/

GameUpQt::GameUpQt(QQuickItem *parent): QQuickItem(parent)
  , d_ptr(new GameUpQtPrivate) {
    qRegisterMetaType<GameUpQt::ServerOps>("GameUpQt::ServerOps");
    connect(d_ptr, &GameUpQtPrivate::reqComplete, this, &GameUpQt::reqComplete);
}

void GameUpQt::setApiKey(QString apiKey) {
    Q_D(GameUpQt);
    d->setApiKey(apiKey);
    emit apiKeyChanged(apiKey);
}
/*!
    \fn bool GameUpQt::ping()
    \inmodule GameUpQt

    \brief pings GameUp server

    \b {Sync mode}: Returns \c true if GameUp server accessible otherwise returns \c false.\n
    \b {Async mode}: Emits \l {pingResultChanged} where \a ok is \c true if GameUp server accessible otherwise returns \c false.
*/
bool GameUpQt::ping() {
    Q_D(GameUpQt);
    return d->ping();
}
/*!
    \fn QString GameUpQt::login(LoginType loginType, const QString &username)
    \inmodule GameUpQt

    \brief Logging in to GameUp server

    \b {Sync mode}: Returns gamer's \c token, generated by GameUp server or empty sting in case of login failure\n
    \b {Async mode}: Emits \l {loginCompleted} where \a token is gamer's \c token, generated by GameUp server or empty sting in case of login failure

*/

QString GameUpQt::login(LoginType loginType, const QString &username) {
    Q_D(GameUpQt);
    return d->login(loginType, username);
}

Gamer *GameUpQt::gamer() {
    Q_D(GameUpQt);
    return d->getGamer();
}

Leaderboard *GameUpQt::leaderboard(const QString &id) {
    Q_D(GameUpQt);
    return d->getLeaderboard(id);
}

/*!
    \fn void GameUpQt::addUserToken(const QString &username, const QString &token)
    \inmodule GameUpQt

    \brief Add user token to identify user by \a username

    Allows GameUpQt class be aware if there is a token, previously taken by login procedure\n
    The idea is to reuse saved at last app start token for login or gamer intercations procedures

*/

void GameUpQt::addUserToken(const QString &username, const QString &token) {
    Q_D(GameUpQt);
    d->addUserToken(username, token);
}

/*!
    \fn void GameUpQt::updateGamerLeaderboard(const QString &username)
    \inmodule GameUpQt

    \brief Request to get gamer's leaderbord records from GameUp server

    \b {Sync mode}: Waiting until data gets updated\n
    \b {Async mode}: Returns immediately. Emits \l {gamerLeaderboardUpdated} when data arrived

*/

void GameUpQt::updateGamerLeaderboard(const QString &username) {
    Q_D(GameUpQt);
    d->updateLeaderboard(username);
}

/*!
    \fn void GameUpQt::updateGamerAchievments(const QString &username)
    \inmodule GameUpQt

    \brief Request to get gamer's achievments records from GameUp server

    \b {Sync mode}: Waiting until data gets updated\n
    \b {Async mode}: Returns immediately. Emits \l {gamerAchievmentsUpdated} when data arrived

*/

void GameUpQt::updateGamerAchievments(const QString &username) {
    Q_D(GameUpQt);
    d->updateGamerAchievments(username);
}

/*!
    \fn void GameUpQt::updateGamerRank(const QString &username)
    \inmodule GameUpQt

    \brief Request to get gamer's rank records from GameUp server

    \b {Sync mode}: Waiting until data gets updated\n
    \b {Async mode}: Returns immediately. Emits \l {gamerRankUpdated} when data arrived

*/

void GameUpQt::updateGamerRank(const QString &username) {
    Q_D(GameUpQt);
    d->updateGamerRank(username);
}

/*!
    \fn void GameUpQt::updateGamerData(const QString &username)
    \inmodule GameUpQt

    \brief Request to get gamer's data from GameUp server

    \b {Sync mode}: Waiting until data gets updated\n
    \b {Async mode}: Returns immediately. Emits \l {gamerDataUpdated} when data arrived

*/

void GameUpQt::updateGamerData(const QString &username) {
    Q_D(GameUpQt);
    d->updateGamerData(username);
}

/*!
    \fn void GameUpQt::setLeaderboardScore(const QString &username, const QString &leaderboardId, int score, const QString &metadata)
    \inmodule GameUpQt

    \brief Request to get gamer's Leaderboard score and metadata

    \b {Sync mode}: Waiting until data gets updated\n
    \b {Async mode}: Returns immediately. Emits \l {gamerRankUpdated} when data arrived

*/

void GameUpQt::setLeaderboardScore(const QString &username, const QString &leaderboardId, int score, const QString &metadata) {
    Q_D(GameUpQt);
    d->setLeaderboardID(leaderboardId);
    d->setLeaderboardScore(username, score, metadata);
}

void GameUpQt::setAsyncMode(bool asyncMode) {
    Q_D(GameUpQt);
    d->setAsyncMode(asyncMode);
    emit asyncModeChanged(asyncMode);
}
#ifdef QT_WEBVIEW_WEBENGINE_BACKEND
void GameUpQt::setWebView(QQuickWebEngineView *webView) {
#else
void GameUpQt::setWebView(QQuickWebView *webView) {
#endif
    Q_D(GameUpQt);
    d->setWebView(webView);
    emit webViewChanged();
}

void GameUpQt::reqComplete(GameUpQt::ServerOps op) {
    //qDebug() << "got op:" << op;
    Q_D(GameUpQt);
    if (op == Ping) {
        bool res = (d->getLasterror() == QNetworkReply::NoError);
        emit pingResultChanged(res);
    } else if (op == Login) {
        emit loginCompleted(d->getLastToken());
    } else if (op == LeaderboardUpdate) {
        emit gamerLeaderboardUpdated();
        emit leaderboardChanged();
    } else if (op == GamerDataUpdate) {
        emit gamerDataUpdated();
        emit gamerChanged();
    } else if (op == GamerRankUpdate) {
        emit gamerRankUpdated();
    } else if (op == GamerAchievmentsUpdate) {
        emit gamerAchievmentsUpdated();
    } else if (op == SetLeaderboardScore) {
        emit leaderboardScoreSetFinished();
    }
}

QString GameUpQt::apiKey() const {
    Q_D(const GameUpQt);
    return d->apiKey();
}

bool GameUpQt::asyncMode() const {
    Q_D(const GameUpQt);
    return d->getAsyncMode();
}

#ifdef QT_WEBVIEW_WEBENGINE_BACKEND
QQuickWebEngineView *GameUpQt::webView() const {
#else
QQuickWebView *GameUpQt::webView() const {
#endif
    Q_D(const GameUpQt);
    return d->webView();
}
